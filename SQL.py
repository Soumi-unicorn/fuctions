# -*- coding: utf-8 -*-
"""Untitled12.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DeEL4e-KjjAOrPfKMk9sqTVBZCWBuuCf
"""



""" 1-Identify the primary keys and foreign keys in maven movies db. Discuss the differences


ChatGPT said:
✅ 1. Primary Keys and Foreign Keys in the Maven Movies Database
In the Maven Movies Database (used in SQL learning platforms), the schema includes tables like film, actor, rental, inventory, customer, payment, etc.

🔹 Primary Keys – Uniquely identify each row in a table:
Table	Primary Key
actor	actor_id
address	address_id
category	category_id
city	city_id
country	country_id
customer	customer_id
film	film_id
inventory	inventory_id
language	language_id
payment	payment_id
rental	rental_id
staff	staff_id
store	store_id

🔹 Foreign Keys – Reference primary keys from other tables:
Table	Foreign Key(s)	References
film_actor	film_id, actor_id	film, actor
film	language_id	language
inventory	film_id, store_id	film, store
rental	inventory_id, customer_id, staff_id	inventory, customer, staff
payment	rental_id, customer_id, staff_id	rental, customer, staff
customer	store_id, address_id	store, address
address	city_id	city
city	country_id	country
store	address_id, staff_id (manager)	address, staff

🆚 Difference Between Primary Key and Foreign Key
Feature	Primary Key	Foreign Key
Purpose	Uniquely identifies each record	Establishes a relationship between tables
Uniqueness	Must be unique and NOT NULL	Can contain duplicate values
Null Values	Not allowed	Allowed unless specified otherwise
Table Role	Defined in the current table	Refers to a key in another table
Example	film.film_id	inventory.film_id → film.film_id

Would you like an ER diagram or query examples showing how these keys work in joins?







You said:
1. Primary Keys and Foreign Keys in the Maven Movies Database
In the Maven Movies Database (used in SQL learning platforms), the schema includes tables like film, actor, rental, inventory, customer, payment, etc.

🔹 Primary Keys – Uniquely identify each row in a table:
Table	Primary Key
actor	actor_id
address	address_id
category	category_id
city	city_id
country	country_id
customer	customer_id
film	film_id
inventory	inventory_id
language	language_id
payment	payment_id
rental	rental_id
staff	staff_id
store	store_id

🔹 Foreign Keys – Reference primary keys from other tables:
Table	Foreign Key(s)	References
film_actor	film_id, actor_id	film, actor
film	language_id	language
inventory	film_id, store_id	film, store
rental	inventory_id, customer_id, staff_id	inventory, customer, staff
payment	rental_id, customer_id, staff_id	rental, customer, staff
customer	store_id, address_id	store, address
address	city_id	city
city	country_id	country
store	address_id, staff_id (manager)	address, staff

🆚 Difference Between Primary Key and Foreign Key
Feature	Primary Key	Foreign Key
Purpose	Uniquely identifies each record	Establishes a relationship between tables
Uniqueness	Must be unique and NOT NULL	Can contain duplicate values
Null Values	Not allowed	Allowed unless specified otherwise
Table Role	Defined in the current table	Refers to a key in another table
Example	film.film_id	inventory.film_id → film.film_id

Would you like an ER diagram or query examples showing how these keys work in joins?








1. Primary Keys and Foreign Keys in the Maven Movies Database
In the Maven Movies Database (used in SQL learning platforms), the schema includes tables like film, actor, rental, inventory, customer, payment, etc.

🔹 Primary Keys – Uniquely identify each row in a table:
Table	Primary Key
actor	actor_id
address	address_id
category	category_id
city	city_id
country	country_id
customer	customer_id
film	film_id
inventory	inventory_id
language	language_id
payment	payment_id
rental	rental_id
staff	staff_id
store	store_id

🔹 Foreign Keys – Reference primary keys from other tables:
Table	Foreign Key(s)	References
film_actor	film_id, actor_id	film, actor
film	language_id	language
inventory	film_id, store_id	film, store
rental	inventory_id, customer_id, staff_id	inventory, customer, staff
payment	rental_id, customer_id, staff_id	rental, customer, staff
customer	store_id, address_id	store, address
address	city_id	city
city	country_id	country
store	address_id, staff_id (manager)	address, staff

🆚 Difference Between Primary Key and Foreign Key
Feature	Primary Key	Foreign Key
Purpose	Uniquely identifies each record	Establishes a relationship between tables
Uniqueness	Must be unique and NOT NULL	Can contain duplicate values
Null Values	Not allowed	Allowed unless specified otherwise
Table Role	Defined in the current table	Refers to a key in another table
Example	film.film_id	inventory.film_id → film.film_id

Would you like an ER diagram or query examples showing how these keys work in joins?




1. Primary Keys and Foreign Keys in the Maven Movies Database
In the Maven Movies Database (used in SQL learning platforms), the schema includes tables like film, actor, rental, inventory, customer, payment, etc.

🔹 Primary Keys – Uniquely identify each row in a table:
Table	Primary Key
actor	actor_id
address	address_id
category	category_id
city	city_id
country	country_id
customer	customer_id
film	film_id
inventory	inventory_id
language	language_id
payment	payment_id
rental	rental_id
staff	staff_id
store	store_id

🔹 Foreign Keys – Reference primary keys from other tables:
Table	Foreign Key(s)	References
film_actor	film_id, actor_id	film, actor
film	language_id	language
inventory	film_id, store_id	film, store
rental	inventory_id, customer_id, staff_id	inventory, customer, staff
payment	rental_id, customer_id, staff_id	rental, customer, staff
customer	store_id, address_id	store, address
address	city_id	city
city	country_id	country
store	address_id, staff_id (manager)	address, staff

🆚 Difference Between Primary Key and Foreign Key
Feature	Primary Key	Foreign Key
Purpose	Uniquely identifies each record	Establishes a relationship between tables
Uniqueness	Must be unique and NOT NULL	Can contain duplicate values
Null Values	Not allowed	Allowed unless specified otherwise
Table Role	Defined in the current table	Refers to a key in another table
Example	film.film_id	inventory.film_id → film.film_id

Would you like an ER diagram or query examples showing how these keys work in joins?







 2- List all details of actors





ChatGPT said:
To list all details of actors in the Maven Movies Database, you can use the following SQL query:

sql
Copy
Edit
SELECT * FROM actor;
✅ Explanation:
SELECT * means select all columns.

FROM actor specifies the table you're selecting from.

This will return columns like:

actor_id

first_name

last_name

last_update

Would you like to filter by a specific actor name or sort the list alphabetically?







You said:
 3 -List all customer information from DB.


ChatGPT said:
To list all customer information from the Maven Movies Database, use the following SQL query:

sql
Copy
Edit
SELECT * FROM customer;
✅ This will return all columns in the customer table, such as:
customer_id

store_id

first_name

last_name

email

address_id

active

create_date

last_update

Would you like to filter only active customers or show full names with email?







You said:
 4 -List different countries.


ChatGPT said:
To list different countries from the Maven Movies Database, use this SQL query:

sql
Copy
Edit
SELECT DISTINCT country FROM country;
✅ Explanation:
DISTINCT ensures no duplicate country names.

country is the column.

country is also the table name in this database.

Would you like to sort the countries alphabetically as well?







You said:
 5 -Display all active customers.


ChatGPT said:
To display all active customers in the Maven Movies Database, use this SQL query:

sql
Copy
Edit
SELECT * FROM customer
WHERE active = 1;
✅ Explanation:
The active column typically holds values 1 (active) or 0 (inactive).

This query filters only those with active = 1.

Would you like to show only selected columns like name and email?







You said:
 List of all rental IDs for customer with ID 1.


ChatGPT said:
To list all rental IDs for the customer with ID 1, use the following SQL query:

sql
Copy
Edit
SELECT rental_id
FROM rental
WHERE customer_id = 1;
✅ Explanation:
rental is the table storing rental transactions.

rental_id is the unique ID for each rental.

customer_id = 1 filters results to only that customer.

Would you like to include rental dates or film details as well?







You said:
 Display all the films whose rental duration is greater than 5 .


ChatGPT said:
To display all films whose rental duration is greater than 5 days, use this SQL query:

sql
Copy
Edit
SELECT *
FROM film
WHERE rental_duration > 5;
✅ Explanation:
film is the table containing movie details.

rental_duration is the number of days a film can be rented.

The WHERE clause filters only films with rental duration greater than 5.

Would you like to see only selected columns like title and rental duration?







You said:
List the total number of films whose replacement cost is greater than $15 and less than $20.


ChatGPT said:
To count the total number of films with a replacement cost greater than $15 and less than $20, use this SQL query:

sql
Copy
Edit
SELECT COUNT(*) AS total_films
FROM film
WHERE replacement_cost > 15 AND replacement_cost < 20;
✅ Explanation:
COUNT(*) counts all rows that match the condition.

replacement_cost is the cost to replace a lost or damaged film.

AS total_films gives a readable name to the result column.

Would you also like to list the titles of these films?







You said:
Display the count of unique first names of actors.


ChatGPT said:
To display the count of unique first names of actors in the Maven Movies database, use this SQL query:

sql
Copy
Edit
SELECT COUNT(DISTINCT first_name) AS unique_first_names
FROM actor;
✅ Explanation:
DISTINCT first_name filters out duplicates.

COUNT() counts how many unique first names exist.

AS unique_first_names labels the result column.

Would you like to list the unique names as well?







You said:
Display the first 10 records from the customer table .


ChatGPT said:
To display the first 10 records from the customer table, use this SQL query:

sql
Copy
Edit
SELECT *
FROM customer
LIMIT 10;
✅ Explanation:
LIMIT 10 restricts the output to only the first 10 rows.

SELECT * retrieves all columns from the customer table.

Would you like to sort the customers by name or ID in this list?







You said:
 Display the first 3 records from the customer table whose first name starts with ‘b’.


ChatGPT said:
To display the first 3 records from the customer table whose first name starts with 'B', use this SQL query:

sql
Copy
Edit
SELECT *
FROM customer
WHERE first_name LIKE 'B%'
LIMIT 3;
✅ Explanation:
WHERE first_name LIKE 'B%' filters customers whose first name starts with the letter 'B'.

LIMIT 3 restricts the results to the first 3 matching records.

Would you like to sort them in any particular order (e.g., by last name or ID)?







You said:
Display the names of the first 5 movies which are rated as ‘G’.


ChatGPT said:
To display the names of the first 5 movies that are rated as 'G' in the Maven Movies database, use this SQL query:

sql
Copy
Edit
SELECT title
FROM film
WHERE rating = 'G'
LIMIT 5;
✅ Explanation:
WHERE rating = 'G' filters the films to only those rated "G".

LIMIT 5 restricts the output to the first 5 movies.

Would you like to include other details such as release year or rental duration in the result?

13)Find all customers whose first name starts with "a".
Ans)SELECT *
FROM customer
WHERE first_name LIKE 'A%';
 14)Find all customers whose first name ends with "a".
 Ans)SELECT *
FROM customer
WHERE first_name LIKE '%a';
15) Display the list of first 4 cities which start and end with ‘a’ .
Ans)SELECT city
FROM city
WHERE city LIKE 'A%' AND city LIKE '%A'
LIMIT 4;
16) Find all customers whose first name have "NI" in any position.
Ans)SELECT *
FROM customer
WHERE first_name LIKE '%NI%';
17)SELECT *
FROM customer
WHERE first_name LIKE '_r%';
18)SELECT *
FROM customer
WHERE first_name LIKE 'A%' AND LENGTH(first_name) >= 5;
19)SELECT *
FROM customer
WHERE first_name LIKE 'A%' AND first_name LIKE '%O';
20)SELECT *
FROM film
WHERE rating IN ('PG', 'PG-13');
21)SELECT *
FROM film
WHERE length BETWEEN 50 AND 100;
22)SELECT *
FROM actor
LIMIT 50;
23)SELECT DISTINCT film_id
FROM inventory;









Functions




1)SELECT COUNT(*) AS total_rentals
FROM rental;


2)SELECT AVG(rental_duration) AS average_rental_duration
FROM film;



3)SELECT UPPER(first_name) AS first_name_uppercase,
       UPPER(last_name) AS last_name_uppercase
FROM customer;




4)SELECT rental_id, MONTH(rental_date) AS rental_month
FROM rental;





5)SELECT customer_id, COUNT(*) AS rental_count
FROM rental
GROUP BY customer_id;




6)SELECT store_id, SUM(amount) AS total_revenue
FROM payment
GROUP BY store_id;





7)SELECT c.category_id,
       cat.name AS category_name,
       COUNT(r.rental_id) AS rental_count
FROM film_category fc
JOIN film f ON fc.film_id = f.film_id
JOIN rental r ON f.film_id = r.film_id
JOIN category cat ON fc.category_id = cat.category_id
GROUP BY c.category_id, cat.name;





8)SELECT l.name AS language_name,
       AVG(f.rental_rate) AS average_rental_rate
FROM film f
JOIN language l ON f.language_id = l.language_id
GROUP BY l.name;











JOINS





9)SELECT f.title AS movie_title,
       c.first_name AS customer_first_name,
       c.last_name AS customer_last_name
FROM film f
JOIN inventory i ON f.film_id = i.film_id
JOIN rental r ON i.inventory_id = r.inventory_id
JOIN customer c ON r.customer_id = c.customer_id;







10)SELECT a.first_name, a.last_name
FROM actor a
JOIN film_actor fa ON a.actor_id = fa.actor_id
JOIN film f ON fa.film_id = f.film_id
WHERE f.title = 'Gone with the Wind';






11)SELECT c.first_name, c.last_name, SUM(p.amount) AS total_spent
FROM customer c
JOIN payment p ON c.customer_id = p.customer_id
JOIN rental r ON p.rental_id = r.rental_id
GROUP BY c.customer_id;





12)SELECT c.first_name, c.last_name, f.title AS movie_title
FROM customer c
JOIN address a ON c.address_id = a.address_id
JOIN city ci ON a.city_id = ci.city_id
JOIN rental r ON c.customer_id = r.customer_id
JOIN inventory i ON r.inventory_id = i.inventory_id
JOIN film f ON i.film_id = f.film_id
WHERE ci.city = 'London'
ORDER BY c.last_name, c.first_name, f.title;







13)SELECT f.title AS movie_title, COUNT(r.rental_id) AS rental_count
FROM film f
JOIN inventory i ON f.film_id = i.film_id
JOIN rental r ON i.inventory_id = r.inventory_id
GROUP BY f.film_id
ORDER BY rental_count DESC
LIMIT 5;






14)SELECT c.customer_id, c.first_name, c.last_name
FROM customer c
JOIN rental r ON c.customer_id = r.customer_id
JOIN inventory i ON r.inventory_id = i.inventory_id
WHERE i.store_id IN (1, 2)
GROUP BY c.customer_id
HAVING COUNT(DISTINCT i.store_id) = 2;













Windows Function:


1)SELECT c.customer_id, c.first_name, c.last_name, SUM(p.amount) AS total_spent
FROM customer c
JOIN payment p ON c.customer_id = p.customer_id
GROUP BY c.customer_id
ORDER BY total_spent DESC;




2)SELECT
    f.title AS film_title,
    r.rental_date,
    SUM(p.amount) OVER (PARTITION BY f.film_id ORDER BY r.rental_date) AS cumulative_revenue
FROM film f
JOIN inventory i ON f.film_id = i.film_id
JOIN rental r ON i.inventory_id = r.inventory_id
JOIN payment p ON r.rental_id = p.rental_id
ORDER BY f.film_id, r.rental_date;





3)SELECT
    f.film_id,
    f.title AS film_title,
    f.length AS film_length,
    AVG(r.rental_duration) AS average_rental_duration
FROM film f
JOIN inventory i ON f.film_id = i.film_id
JOIN rental r ON i.inventory_id = r.inventory_id
GROUP BY f.length, f.film_id
ORDER BY f.length;





4)WITH RankedFilms AS (
    SELECT
        f.film_id,
        f.title AS film_title,
        c.category_id,
        cat.name AS category_name,
        COUNT(r.rental_id) AS rental_count,
        ROW_NUMBER() OVER (PARTITION BY c.category_id ORDER BY COUNT(r.rental_id) DESC) AS rank
    FROM film f
    JOIN film_category c ON f.film_id = c.film_id
    JOIN category cat ON c.category_id = cat.category_id
    LEFT JOIN inventory i ON f.film_id = i.film_id
    LEFT JOIN rental r ON i.inventory_id = r.inventory_id
    GROUP BY f.film_id, f.title, c.category_id, cat.name
)
SELECT
    film_id,
    film_title,
    category_name,
    rental_count
FROM RankedFilms
WHERE rank <= 3
ORDER BY category_name, rank;


5)WITH CustomerRentalCounts AS (
    SELECT
        c.customer_id,
        COUNT(r.rental_id) AS total_rentals
    FROM customer c
    LEFT JOIN rental r ON c.customer_id = r.customer_id
    GROUP BY c.customer_id
),
AverageRentalCount AS (
    SELECT AVG(total_rentals) AS avg_rentals
    FROM CustomerRentalCounts
)
SELECT
    crc.customer_id,
    crc.total_rentals,
    arc.avg_rentals,
    (crc.total_rentals - arc.avg_rentals) AS rental_difference
FROM CustomerRentalCounts crc
CROSS JOIN AverageRentalCount arc
ORDER BY crc.customer_id;
  



6)SELECT
    YEAR(p.payment_date) AS year,
    MONTH(p.payment_date) AS month,
    SUM(p.amount) AS total_revenue
FROM payment p
GROUP BY YEAR(p.payment_date), MONTH(p.payment_date)
ORDER BY year, month;




7)WITH TotalSpending AS (
    SELECT
        c.customer_id,
        SUM(p.amount) AS total_spent
    FROM customer c
    JOIN payment p ON c.customer_id = p.customer_id
    GROUP BY c.customer_id
),
PercentileThreshold AS (
    SELECT
        PERCENTILE_CONT(0.8) WITHIN GROUP (ORDER BY total_spent) AS percentile_80
    FROM TotalSpending
)
SELECT
    ts.customer_id,
    ts.total_spent
FROM TotalSpending ts
JOIN PercentileThreshold pt ON ts.total_spent >= pt.percentile_80
ORDER BY ts.total_spent DESC;




8)WITH RentalsPerCategory AS (
    SELECT
        fc.category_id,
        c.name AS category_name,
        COUNT(r.rental_id) AS rental_count
    FROM rental r
    JOIN inventory i ON r.inventory_id = i.inventory_id
    JOIN film_category fc ON i.film_id = fc.film_id
    JOIN category c ON fc.category_id = c.category_id
    GROUP BY fc.category_id, c.name
)
SELECT
    category_name,
    rental_count,
    SUM(rental_count) OVER (ORDER BY rental_count DESC) AS running_total
FROM RentalsPerCategory
ORDER BY rental_count DESC;






9)WITH FilmRentalCounts AS (
    SELECT
        f.film_id,
        f.title,
        fc.category_id,
        COUNT(r.rental_id) AS rental_count
    FROM rental r
    JOIN inventory i ON r.inventory_id = i.inventory_id
    JOIN film_category fc ON i.film_id = fc.film_id
    JOIN film f ON fc.film_id = f.film_id
    GROUP BY f.film_id, fc.category_id
),
CategoryAvgRentals AS (
    SELECT
        category_id,
        AVG(rental_count) AS avg_rental_count
    FROM FilmRentalCounts
    GROUP BY category_id
)
SELECT
    fr.film_id,
    fr.title,
    fr.rental_count,
    ca.avg_rental_count
FROM FilmRentalCounts fr
JOIN CategoryAvgRentals ca ON fr.category_id = ca.category_id
WHERE fr.rental_count < ca.avg_rental_count
ORDER BY fr.rental_count ASC;




10)SELECT
    YEAR(p.payment_date) AS year,
    MONTH(p.payment_date) AS month,
    SUM(p.amount) AS total_revenue
FROM payment p
GROUP BY YEAR(p.payment_date), MONTH(p.payment_date)
ORDER BY total_revenue DESC
LIMIT 5;















Normalisation & CTE







1)First Normal Form (1NF):
Definition of 1NF:
A table is in First Normal Form (1NF) if it satisfies the following conditions:

Each column contains atomic values (no repeating groups or arrays).

Each column contains values of a single type (i.e., no mixed data types).

Each column contains only one value per row (no multi-valued attributes).

Each row is unique and can be identified by a primary key.

Identifying a table that violates 1NF in the Sakila database:
Let's consider the rental table as an example.

The rental table in the Sakila database might look like this:

rental_id	rental_date	inventory_id	customer_id	staff_id	payment_id
1	2023-05-01	1	1	1	1
2	2023-05-01	2	1	1	2
3	2023-05-01	3	2	2	3

Now, let’s assume the rental table has a column movie_titles which stores multiple values for each rental (i.e., multiple movies rented in one record).

rental_id	rental_date	inventory_id	customer_id	movie_titles
1	2023-05-01	1	1	"The Matrix, The Godfather"
2	2023-05-01	2	1	"Inception, Titanic"
3	2023-05-01	3	2	"The Dark Knight, Pulp Fiction"

In this table, the movie_titles column contains multiple values (movies) within the same field, which violates 1NF, as columns should only hold atomic values (individual values, not lists or arrays).

How to Normalize the Table to Achieve 1NF:
To normalize the table and ensure it satisfies 1NF, we must eliminate the multi-valued attribute (movie_titles) and ensure that each column contains atomic (singular) values.

We can achieve this by splitting the movies into separate rows. For each rental, instead of storing multiple movies in a single column, we store one movie per row.

Normalized Table in 1NF:
rental_id	rental_date	inventory_id	customer_id	staff_id	payment_id	movie_title
1	2023-05-01	1	1	1	1	The Matrix
1	2023-05-01	1	1	1	1	The Godfather
2	2023-05-01	2	1	1	2	Inception
2	2023-05-01	2	1	1	2	Titanic
3	2023-05-01	3	2	2	3	The Dark Knight
3	2023-05-01	3	2	2	3	Pulp Fiction

Explanation of Normalization Process:
The movie_titles column has been removed and split into multiple rows, where each row represents a single movie rental.

Now, each column contains atomic values (only one movie title per row).

The table is still linked to the rental_id and other attributes (such as inventory_id, customer_id, etc.), so there is no data loss, and it is now in 1NF.

Key Points:
Each column contains only atomic values (single values).

There are no repeating groups or multi-valued attributes.

The rental_id still serves as a primary key for the table, but multiple rows can share the same rental_id if multiple movies were rented as part of that transaction.





2)Second Normal Form (2NF):
Definition of 2NF:
A table is in Second Normal Form (2NF) if:

It is already in First Normal Form (1NF).

It does not contain any partial dependencies (i.e., no non-prime attribute is dependent on a part of a candidate key).

In simple terms, for a table to be in 2NF, every non-key attribute must be fully dependent on the entire primary key, and not just a part of it. If a table has a composite primary key (a primary key made up of more than one column), each non-key attribute must depend on the whole composite key, not just a part of it.

Example Table: rental Table in Sakila Database:
Let’s examine the rental table in the Sakila database. We will check whether it satisfies 2NF.

Assume the rental table has the following structure:

rental_id	rental_date	inventory_id	customer_id	staff_id	payment_id
1	2023-05-01	1	1	1	1
2	2023-05-01	2	1	1	2
3	2023-05-01	3	2	2	3

Step 1: Is the table in 1NF?
We previously normalized the rental table to 1NF by ensuring it doesn't have multi-valued columns or arrays. So, yes, it is in 1NF.

Step 2: Identify the primary key:
Primary Key: The primary key for this table is likely rental_id because it uniquely identifies each row in the table.

The table also contains foreign keys: inventory_id, customer_id, staff_id, and payment_id.

Step 3: Check for Partial Dependencies (Violation of 2NF):
In the rental table, there is no composite primary key because rental_id is the unique key. Therefore, no non-key attribute can be partially dependent on the key. Since all the non-key attributes (e.g., rental_date, inventory_id, customer_id, staff_id, payment_id) are fully dependent on rental_id, the table is not violating 2NF.

Step 4: 2NF Violation Scenario (if applicable):
Let’s consider a hypothetical scenario in which the rental table has a composite primary key (e.g., rental_id and inventory_id). In this case, the table could violate 2NF if a non-key attribute depends only on part of the composite key.

For example:

rental_id	inventory_id	rental_date	customer_id	staff_id
1	1	2023-05-01	1	1
2	2	2023-05-01	1	1
3	3	2023-05-01	2	2

Here, if rental_date depends only on rental_id (and not on inventory_id), this would be a partial dependency. The rental_date is only dependent on rental_id, and not on the entire composite key (rental_id, inventory_id). This means the table violates 2NF.

Step 5: Steps to Normalize to 2NF:
To normalize the rental table to 2NF, we need to remove partial dependencies. We do this by creating new tables for the attributes that depend on only part of the composite primary key.

Normalization Process (if rental_id and inventory_id were composite keys):

Create a new table for rental information:

We would move rental_date, which is dependent only on rental_id, into a new table that uses rental_id as the primary key.

New table: rental_info

rental_id	rental_date
1	2023-05-01
2	2023-05-01
3	2023-05-01

Leave the remaining attributes in the original table:

The remaining attributes, such as inventory_id, customer_id, staff_id, can stay in the rental table, which now uses rental_id and inventory_id as the composite primary key.

Revised table: rental

rental_id	inventory_id	customer_id	staff_id
1	1	1	1
2	2	1	1
3	3	2	2

Now, each non-key attribute is fully dependent on the whole primary key, ensuring that the table is in 2NF.

Conclusion:
In this case, the rental table was in 2NF to begin with since there was no composite key. However, if there had been a composite key, we would have normalized the table by removing partial dependencies, ensuring all non-key attributes depend on the entire primary key.

3)Third Normal Form (3NF):
Definition of 3NF:
A table is in Third Normal Form (3NF) if:

It is already in Second Normal Form (2NF).

It does not contain any transitive dependencies (i.e., non-prime attributes should not depend on other non-prime attributes).

In simpler terms:

A table is in 3NF if all non-key attributes are directly dependent on the primary key, and not on other non-key attributes.

If a non-key attribute is dependent on another non-key attribute (called a transitive dependency), the table is not in 3NF.

Example of a Table Violating 3NF: customer Table
The customer table in the Sakila database can be used as an example for violation of 3NF.

Structure of customer Table:
customer_id	first_name	last_name	email	address_id	store_id	active	create_date	last_update	city_id	country_id
1	John	Doe	john.doe@example.com	10	1	1	2023-01-01	2023-01-01	5	30
2	Alice	Smith	alice.smith@example.com	20	1	1	2023-01-02	2023-01-02	6	30

Primary Key:
The primary key is customer_id.

Transitive Dependencies:
In the customer table, there are two non-key attributes (country_id and city_id) that are dependent on other non-key attributes (city_id and country_id). Specifically, country_id is determined by city_id. This means country_id is transitively dependent on customer_id via city_id.

city_id can determine country_id, but country_id is not part of the primary key. This is an example of a transitive dependency.

Steps to Normalize to 3NF:
Eliminate Transitive Dependencies:
To bring the table into 3NF, we need to remove the transitive dependency between city_id and country_id.

Create New Table for City and Country Information:
Since country_id depends on city_id, we can create a new table, city, to store city_id and country_id. This way, customer will reference city_id as a foreign key, and country_id will no longer be stored directly in the customer table.

Update the customer Table:
Remove the country_id from the customer table and keep the city_id, which will reference the city table.

New Structure:

a. customer table (after 3NF normalization):

customer_id	first_name	last_name	email	address_id	store_id	active	create_date	last_update	city_id
1	John	Doe	john.doe@example.com	10	1	1	2023-01-01	2023-01-01	5
2	Alice	Smith	alice.smith@example.com	20	1	1	2023-01-02	2023-01-02	6

b. New city table (after 3NF normalization):

city_id	city_name	country_id
5	London	30
6	New York	30

c. New country table (optional - if needed):

If we want to store more details about the country, we can create a separate country table that includes country_id and country_name.

country_id	country_name
30	UK

Explanation of Changes:
customer table now only contains the city_id column, which references the new city table. There is no direct country_id in the customer table, eliminating the transitive dependency.

The city table now contains city_id and country_id, which maintains the relationship between cities and countries.

The country table is optional but can be created if we want to store more details about countries (e.g., country names).

Conclusion:
By removing the transitive dependency between city_id and country_id, we have successfully normalized the customer table to 3NF. Now, the customer table has only direct dependencies on the primary key (customer_id), ensuring that it is in 3NF.




4)Normalization Process: From Unnormalized Form (UNF) to 2NF
Let's go step by step to normalize a table from Unnormalized Form (UNF) to Second Normal Form (2NF) using the customer table in the Sakila database.

Step 1: Understanding the Unnormalized Form (UNF)
An unnormalized form (UNF) typically contains repeated groups of data and possibly multivalued attributes. The data might contain redundancy, leading to anomalies when inserting, updating, or deleting records.

In our case, the customer table might look like this in UNF:

customer_id	first_name	last_name	address_id	store_id	active	create_date	last_update	city_name	country_name
1	John	Doe	10	1	1	2023-01-01	2023-01-01	London	UK
2	Alice	Smith	20	2	1	2023-01-02	2023-01-02	New York	USA
3	Bob	Johnson	30	1	0	2023-01-03	2023-01-03	London	UK
4	Charlie	Brown	10	2	1	2023-01-04	2023-01-04	New York	USA

Issues with the UNF table:
The table includes city_name and country_name, which are repeating information. If a customer is from London, for instance, London and UK will be repeated for every customer from the same location.

Data redundancy: If a new city (or country) is added, we must update each customer record associated with that city. Otherwise, it could lead to inconsistent data.

Step 2: First Normal Form (1NF)
The first step is to ensure the table is in First Normal Form (1NF). A table is in 1NF if:

All columns contain atomic (indivisible) values (no repeating groups or arrays).

Each column must contain only a single value for each record.

The order in which data is stored does not matter.

In our customer table, to bring it into 1NF, we remove repeating groups and ensure that every field contains atomic values.

After applying 1NF, we can remove the city_name and country_name columns, and the customer table now looks like this:

customer_id	first_name	last_name	address_id	store_id	active	create_date	last_update
1	John	Doe	10	1	1	2023-01-01	2023-01-01
2	Alice	Smith	20	2	1	2023-01-02	2023-01-02
3	Bob	Johnson	30	1	0	2023-01-03	2023-01-03
4	Charlie	Brown	10	2	1	2023-01-04	2023-01-04

City and Country data would now be placed in separate tables.

Step 3: Second Normal Form (2NF)
A table is in Second Normal Form (2NF) if:

It is in 1NF.

It does not contain partial dependencies, i.e., all non-key attributes are fully functionally dependent on the primary key.

The current customer table has partial dependencies:

first_name, last_name, active, create_date, and last_update are fully dependent on the primary key, customer_id.

However, the address_id can be partially dependent on the primary key if there is a separate table where address_id is the primary key.

Steps to Normalize to 2NF:
To bring the customer table to 2NF, we need to eliminate partial dependencies by breaking it into smaller tables.

Create an Address Table:
The address_id is dependent on the address information, so it should be placed in a separate address table.

New address table:

address_id	address_line_1	address_line_2	city_id
10	123 Baker St.	Apt. 4B	5
20	456 Elm St.	Suite 10	6
30	789 Oak St.		5

Create a City Table:
The city name is related to the city_id, so we create a new table for the city information.

New city table:

city_id	city_name	country_id
5	London	30
6	New York	31

Create a Country Table:
We create a country table to store information about countries, so we do not repeat country names in every customer record.

New country table:

country_id	country_name
30	UK
31	USA

Updated customer table (in 2NF):
The customer table will now only contain the customer_id, first_name, last_name, store_id, active, and references to the address_id.

customer_id	first_name	last_name	address_id	store_id	active	create_date	last_update
1	John	Doe	10	1	1	2023-01-01	2023-01-01
2	Alice	Smith	20	2	1	2023-01-02	2023-01-02
3	Bob	Johnson	30	1	0	2023-01-03	2023-01-03
4	Charlie	Brown	10	2	1	2023-01-04	2023-01-04

Summary of the Tables After 2NF:
customer table: Contains customer-related details, and address_id is a foreign key referring to the address table.

address table: Contains details about the address, with address_id as the primary key.

city table: Contains city details, with city_id as the primary key.

country table: Contains country details, with country_id as the primary key.





5)WITH ActorFilmCount AS (
    SELECT
        a.actor_id,
        a.first_name,
        a.last_name,
        COUNT(fa.film_id) AS film_count
    FROM actor a
    JOIN film_actor fa ON a.actor_id = fa.actor_id
    GROUP BY a.actor_id, a.first_name, a.last_name
)
SELECT
    first_name,
    last_name,
    film_count
FROM ActorFilmCount
ORDER BY film_count DESC;






6)WITH FilmLanguageInfo AS (
    SELECT
        f.title AS film_title,
        l.name AS language_name,
        f.rental_rate
    FROM film f
    JOIN language l ON f.language_id = l.language_id
)
SELECT
    film_title,
    language_name,
    rental_rate
FROM FilmLanguageInfo
ORDER BY film_title;





7)WITH CustomerRevenue AS (
    SELECT
        c.customer_id,
        c.first_name,
        c.last_name,
        SUM(p.amount) AS total_revenue
    FROM customer c
    JOIN payment p ON c.customer_id = p.customer_id
    GROUP BY c.customer_id, c.first_name, c.last_name
)
SELECT
    customer_id,
    first_name,
    last_name,
    total_revenue
FROM CustomerRevenue
ORDER BY total_revenue DESC;





8)WITH FilmRentalRank AS (
    SELECT
        f.film_id,
        f.title AS film_title,
        f.rental_duration,
        RANK() OVER (ORDER BY f.rental_duration DESC) AS rental_rank
    FROM film f
)
SELECT
    film_id,
    film_title,
    rental_duration,
    rental_rank
FROM FilmRentalRank
ORDER BY rental_rank;





9)WITH CustomerRentalCount AS (
    SELECT
        r.customer_id,
        COUNT(r.rental_id) AS rental_count
    FROM rental r
    GROUP BY r.customer_id
    HAVING COUNT(r.rental_id) > 2
)
SELECT
    c.customer_id,
    c.first_name,
    c.last_name,
    c.email,
    c.address_id,
    crc.rental_count
FROM CustomerRentalCount crc
JOIN customer c ON crc.customer_id = c.customer_id
ORDER BY crc.rental_count DESC;







10)WITH MonthlyRentalCount AS (
    SELECT
        YEAR(rental_date) AS rental_year,
        MONTH(rental_date) AS rental_month,
        COUNT(r.rental_id) AS total_rentals
    FROM rental r
    GROUP BY rental_year, rental_month
)
SELECT
    rental_year,
    rental_month,
    total_rentals
FROM MonthlyRentalCount
ORDER BY rental_year DESC, rental_month DESC;






11)WITH ActorPairs AS (
    SELECT
        fa1.actor_id AS actor1_id,
        fa2.actor_id AS actor2_id,
        fa1.film_id
    FROM film_actor fa1
    JOIN film_actor fa2
        ON fa1.film_id = fa2.film_id
        AND fa1.actor_id < fa2.actor_id  -- To avoid duplicate pairs (e.g., (A, B) and (B, A))
)
SELECT
    a1.actor_id AS actor1_id,
    a2.actor_id AS actor2_id,
    COUNT(ap.film_id) AS films_together






12)To implement a recursive CTE (Common Table Expression) that finds all employees in the staff table who report to a specific manager, considering the reports_to column, we'll need to leverage the recursive nature of CTEs. The idea is to repeatedly join the staff table to find employees at each level of reporting hierarchy.

Recursive CTE Structure:
Base Case: Select the manager (top-level employee).

Recursive Case: Find all employees who report to those already selected in the previous iteration.

Assuming the staff table has columns such as:

staff_id (unique identifier for each employee),

first_name and last_name (employee names),

reports_to (the staff ID of the manager that the employee reports to).

Here is the SQL query using a recursive CTE:

sql
Copy
Edit
WITH RECURSIVE EmployeeHierarchy AS (
    -- Base case: Select the specific manager (e.g., manager with staff_id = 1)
    SELECT
        staff_id,
        first_name,
        last_name,
        reports_to
    FROM staff
    WHERE staff_id = 1  -- Replace with the manager's staff_id for which you want to find reports
    
    UNION ALL
    
    -- Recursive case: Find employees who report to the already selected employees
    SELECT
        s.staff_id,
        s.first_name,
        s.last_name,
        s.reports_to
    FROM staff s
    JOIN EmployeeHierarchy eh ON s.reports_to = eh.staff_id
)
-- Final selection: Select all employees (including the manager and those who report directly or indirectly)
SELECT staff_id, first_name, last_name
FROM EmployeeHierarchy;
Explanation:
Base Case:

The base case of the recursive CTE selects the manager (for example, staff_id = 1 in this case, but you can replace it with any specific manager's ID).

The base case retrieves the staff_id, first_name, last_name, and reports_to for the selected manager.

Recursive Case:

The recursive part of the CTE selects all employees who report to the current employees (those selected in the previous recursive step).

The JOIN condition s.reports_to = eh.staff_id ensures that the query finds employees who report directly to the employees in the EmployeeHierarchy CTE.

Final Selection:

After the recursion completes, the SELECT statement at the end retrieves the list of all employees who report to the specified manager (directly or indirectly).

Notes:
Make sure to replace the condition WHERE staff_id = 1 in the base case with the actual manager's staff_id for whom you want to find the employees reporting to them.

This query will return all employees who report to the specified manager, including those who report directly and those who report indirectly (i.e., through multiple reporting levels).






1)CREATE DATABASE employee_management;
USE employee_management;
CREATE TABLE employees (
    emp_id INTEGER PRIMARY KEY NOT NULL,
    emp_name VARCHAR(100) NOT NULL,
    age INTEGER CHECK (age >= 18),
    email VARCHAR(255) UNIQUE,
    salary DECIMAL(10, 2) DEFAULT 30000
);






2)Purpose of Constraints and Their Role in Maintaining Data Integrity:

Constraints are rules or restrictions applied to columns in a database table to ensure the validity, accuracy, and reliability of the data being stored. By enforcing these rules, constraints help maintain data integrity and prevent the entry of incorrect, incomplete, or inconsistent data into the database. Constraints ensure that the data adheres to predefined rules and maintain the quality of the database over time.

How Constraints Help Maintain Data Integrity:

Enforcing Valid Data: Constraints ensure that only valid data (e.g., proper format, valid range) can be inserted into the database.

Preventing Duplicates: Constraints such as PRIMARY KEY and UNIQUE ensure that no duplicate values are inserted in critical fields.

Maintaining Referential Integrity: Constraints like FOREIGN KEY enforce relationships between tables, ensuring that data in related tables remains consistent.

Ensuring Consistency: Constraints can also ensure that the data is within valid ranges or follows certain conditions (e.g., age must be greater than or equal to 18).

Protecting Non-null Data: By ensuring required fields are not left empty, constraints help preserve data completeness.

Examples of Common Types of Constraints:

PRIMARY KEY: Ensures that each row in a table has a unique identifier. The primary key cannot contain NULL values.

Example: CREATE TABLE employees (emp_id INT PRIMARY KEY, emp_name VARCHAR(100));

FOREIGN KEY: Ensures that a column (or a set of columns) in one table corresponds to the primary key in another table, maintaining relationships between tables.

Example: CREATE TABLE orders (order_id INT, customer_id INT, FOREIGN KEY (customer_id) REFERENCES customers(customer_id));

UNIQUE: Ensures that all values in a column are distinct, preventing duplicate entries in the specified column(s).

Example: CREATE TABLE employees (email VARCHAR(100) UNIQUE);

CHECK: Ensures that all values in a column satisfy a specific condition (e.g., a value within a certain range).

Example: CREATE TABLE employees (age INT CHECK (age >= 18));

NOT NULL: Ensures that a column cannot have a NULL value, thereby enforcing that the column always contains a valid value.

Example: CREATE TABLE employees (emp_name VARCHAR(100) NOT NULL);






3)The NOT NULL constraint is applied to a column to ensure that every record in the table must have a valid value for that column. By enforcing this rule, you guarantee that certain fields (such as name, age, or email) cannot be left empty or undefined. This helps maintain data integrity and ensures that all essential information is provided for each record.

Reasons to Apply the NOT NULL Constraint:

Data Completeness: Certain fields are critical for the business process or logic, such as user names, order dates, or transaction amounts. Without these values, the data might be incomplete and unusable.

Data Accuracy: Preventing NULL values in critical columns ensures that the data being stored is accurate and avoids ambiguities. For example, a person's date_of_birth should always be known, and leaving it NULL would hinder analysis.

Business Logic Enforcement: In many cases, the absence of certain information could break application logic. For instance, if a column represents the status of an order, it should always have a value, preventing NULL from interfering with processing.

Avoiding Errors in Queries: When performing operations (such as calculations, comparisons, or joins) on columns that cannot be NULL, it eliminates the potential complications of NULL handling. Queries involving NULL values often require additional conditions to handle, which can complicate logic and result in errors or performance overhead.

Can a Primary Key Contain NULL Values?
No, a primary key cannot contain NULL values.

Justification:

Uniqueness Requirement: A primary key is used to uniquely identify each row in a table. The primary key constraint guarantees that each value in the primary key column(s) is unique and non-NULL. If a primary key could be NULL, it would violate this uniqueness requirement since multiple NULL values are allowed in a column, which would create ambiguity in identifying rows.

NULL Represents Absence of Value: In relational databases, NULL represents the absence of a value, which makes it unsuitable for uniquely identifying rows. A primary key needs to ensure that every row can be reliably referenced and identified by its key value, and allowing NULL would prevent this.

Thus, by definition, primary keys are always NOT NULL and must contain unique values to serve their purpose of uniquely identifying records in a table.








4)Adding and Removing Constraints in SQL: Steps and Examples
Constraints in SQL help maintain data integrity and enforce business rules. You can add or remove constraints from an existing table using ALTER TABLE.

🔹 Steps to Add a Constraint
Choose the table to modify.

Decide on the constraint type (e.g., PRIMARY KEY, FOREIGN KEY, UNIQUE, CHECK, NOT NULL).

Use ALTER TABLE ... ADD CONSTRAINT to apply the constraint.

✅ Example – Add a UNIQUE constraint:

sql
Copy
Edit
ALTER TABLE customer
ADD CONSTRAINT unique_email UNIQUE (email);
This ensures no two customers can have the same email.

✅ Example – Add a FOREIGN KEY constraint:

sql
Copy
Edit
ALTER TABLE orders
ADD CONSTRAINT fk_customer_id
FOREIGN KEY (customer_id)
REFERENCES customer(customer_id);
🔹 Steps to Remove a Constraint
Identify the name of the constraint to be removed (you may need to look it up via database schema tools or INFORMATION_SCHEMA).

Use ALTER TABLE ... DROP CONSTRAINT (or for MySQL, DROP FOREIGN KEY / DROP PRIMARY KEY).

✅ Example – Remove a UNIQUE constraint:

sql
Copy
Edit
ALTER TABLE customer
DROP CONSTRAINT unique_email;
💡 In MySQL, if it's a foreign key, the syntax changes slightly:

✅ MySQL Example – Remove a FOREIGN KEY constraint:

sql
Copy
Edit
ALTER TABLE orders
DROP FOREIGN KEY fk_customer_id;
✅ MySQL Example – Remove a PRIMARY KEY:

sql
Copy
Edit
ALTER TABLE customer
DROP PRIMARY KEY;
📝 Summary Table:
Action	SQL Command Example
Add UNIQUE	ALTER TABLE tab ADD CONSTRAINT con_name UNIQUE (col);
Add FOREIGN KEY	ALTER TABLE tab ADD CONSTRAINT con_name FOREIGN KEY ...
Drop CONSTRAINT	ALTER TABLE tab DROP CONSTRAINT con_name; (not in MySQL)
Drop FOREIGN KEY (MySQL)	ALTER TABLE tab DROP FOREIGN KEY con_name;





5)Violating constraints in SQL leads to errors that prevent invalid or inconsistent data from being inserted, updated, or deleted. These safeguards are essential for preserving data integrity.

🔍 Consequences of Violating Constraints
1. INSERT Violations
Attempt: Inserting data that breaks a constraint (e.g., a duplicate primary key, null in a NOT NULL column, or invalid foreign key).

Consequence: The row is not inserted and an error is thrown.

Example:
Trying to insert a duplicate customer_id into a table with a primary key constraint:

sql
Copy
Edit
INSERT INTO customer (customer_id, first_name)
VALUES (1, 'Alice');
-- If 1 already exists:
-- Error: Duplicate entry '1' for key 'PRIMARY'
2. UPDATE Violations
Attempt: Updating a value to one that violates a constraint (e.g., changing a valid foreign key to a non-existent one).

Consequence: The update fails with an error.

Example:
Trying to update a store_id in the customer table to a non-existent store:


UPDATE customer
SET store_id = 99
WHERE customer_id = 5;
-- Error: Cannot add or update a child row: a foreign key constraint fails
3. DELETE Violations
Attempt: Deleting a referenced row (e.g., deleting a parent row that is still referenced by child rows).

Consequence: The delete is blocked, unless cascading delete is enabled.

Example:
Trying to delete a customer who has related payment records:


DELETE FROM customer
WHERE customer_id = 1;
-- Error: Cannot delete or update a parent row: a foreign key constraint fails
🔧 Common Constraint Error Messages
Violation Type	Example Error Message
Primary Key	Duplicate entry '1' for key 'PRIMARY'
Foreign Key	Cannot add or update a child row: a foreign key constraint fails
Unique	Duplicate entry 'email@example.com' for key 'unique_email'
Not Null	Column 'first_name' cannot be null
Check	Check constraint 'check_age' is violated


Constraints are essential for maintaining database correctness. Attempting to violate them triggers errors and ensures only valid, consistent data enters or changes in the system.





6)Make product_id the Primary Key

ALTER TABLE products
ADD CONSTRAINT pk_product_id PRIMARY KEY (product_id);
This ensures that:

product_id is unique

product_id is NOT NULL automatically (a requirement for primary keys)

✅ 2. Set a Default Value for price

ALTER TABLE products
ALTER COLUMN price SET DEFAULT 50.00;
🔹 Note: Some databases like MySQL require this syntax:


ALTER TABLE products
MODIFY price DECIMAL(10, 2) DEFAULT 50.00;
✅ Updated Table Constraints Summary
product_id: Primary Key → Unique + Not Null

price: Default value → 50.00 if no price is specified during insertion

Would you like help verifying these constraints or testing them with sample data?
























































"""